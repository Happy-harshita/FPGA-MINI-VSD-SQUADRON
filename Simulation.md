## SIMULATION PROCESS

**Write Testbenches:** For each Verilog module you want to simulate, you need to create a testbench module.

**The testbench will:** Instantiate the Unit Under Test (UUT), which is your Verilog module.

Generate input stimuli (clock, reset, data, control signals).Observe the outputs of the UUT.

Optionally, check if the outputs match the expected behavior (self-checking testbench).

Set up the Simulation Environment:Create a project in your chosen simulation tool or organize your Verilog files.

Add your Verilog module(s) and the corresponding testbench file(s) to the project.S

pecify the top-level simulation module (which will be your testbench).Run the Simulation: Start the simulation in your chosen tool (Virtual Box). 

Analyze the Results:Examine the waveforms generated by the simulator. 

These waveforms will show the time evolution of the inputs and outputs of your module.

Verify that the outputs behave as expected based on the inputs you provided and your understanding of the module's functionality.

Look for any unexpected behavior or errors.

Debug and Iterate: If you find issues in the simulation, go back to your Verilog code, make corrections, and re-run the simulation until the module behaves correctly.

Basic Testbench Example: UART Transmitter (uart_transmitter_tb.v)

Here's a basic testbench for the uart_transmitter module we created earlier:`timescale 1ns/1ps // Define timescale for simulation

module uart_transmitter_tb;

    // Parameters (must match the module)
    parameter CLK_FREQUENCY = 50_000_000;
    parameter BAUD_RATE       = 9600;

    // Signals for the UUT
    reg clk;
    reg rst_n;
    reg [7:0] tx_data;
    reg tx_en;
    wire tx_out;
    wire tx_busy;

    // Instantiate the Unit Under Test (UUT)
    uart_transmitter #(
        .CLK_FREQUENCY(CLK_FREQUENCY),
        .BAUD_RATE(BAUD_RATE)
    ) uut (
        .clk(clk),
        .rst_n(rst_n),
        .tx_data(tx_data),
        .tx_en(tx_en),
        .tx_out(tx_out),
        .tx_busy(tx_busy)
    );

    // Clock generation
    initial begin
        clk = 0;
        forever #10 clk = ~clk; // Generates a 50 MHz clock (period = 20 ns)
    end

    // Stimulus generation
    initial begin
        rst_n = 0;
        tx_en = 0;
        tx_data = 8'd0;

        #20; // Hold reset for 20 ns
        rst_n = 1;

        #100; // Wait for a while

        // Send the byte 8'h41 ('A')
        tx_data = 8'h41;
        tx_en = 1;
        #20; // Hold enable for a short time
        tx_en = 0;

        #((10 * (1_000_000_000 / BAUD_RATE)) / 1000_000); // Wait for one frame (approx. 10 bits) in ms

        // Send the byte 8'h42 ('B')
        tx_data = 8'h42;
        tx_en = 1;
        #20;
        tx_en = 0;

        #((10 * (1_000_000_000 / BAUD_RATE)) / 1000_000);

        $finish; // End the simulation
    end

    // Optional: Add assertions or display statements to check behavior
    initial begin
        $monitor("Time = %t, Reset = %b, Data = %h, Enable = %b, TX Out = %b, Busy = %b",
                $time, rst_n, tx_data, tx_en, tx_out, tx_busy);
    end

endmodule

Explanation of the Testbench:timescale: Defines the time units and precision for the simulation.

Signals: Declares signals that will be connected to the inputs and outputs of the uart_transmitter module.

Instantiation: Creates an instance of the uart_transmitter module named uut. 

The parameters are passed using #(...) and the ports are connected using (...).

Clock Generation: An initial block generates a clock signal with a period of 20 ns (for a 50 MHz frequency).

Stimulus Generation: Another initial block provides the input stimuli:Applies a reset pulse.Waits for some time.

Sets the tx_data to a specific value (e.g., 'A' which is 0x41).Asserts tx_en to start transmission.

De-asserts tx_en.Waits for approximately the time it takes to transmit one frame (start bit + 8 data bits + stop bit).

Sends another byte ('B').Uses $finish to end the simulation.$monitor (Optional): This system task will display the values of the signals during the simulation, which can be helpful for debugging.

To simulate:Save the uart_transmitter.v and uart_transmitter_tb.v files in your simulation project.

Set uart_transmitter_tb as the top-level module for simulation.Run the simulation.

Examine the waveforms of tx_out and tx_busy. You should see the start bit (low), the bits of the transmitted data ('A' then 'B'), and the stop bit (high) on tx_out.

The tx_busy signal should go high during transmission.

You would follow a similar process to create testbenches for the simple_sensor_interface and basic_adder modules, providing appropriate input stimuli and checking their outputs.
